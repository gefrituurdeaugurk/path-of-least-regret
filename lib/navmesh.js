import { triArea2, V, centroidTriangle } from './math.js';
export function buildAdjacency(tris){ const map=new Map(); tris.forEach((t,i)=>map.set(i,[])); const samePt=(p,q)=>p===q||(Math.abs(p.x-q.x)<1e-9&&Math.abs(p.y-q.y)<1e-9); const sameEdge=(e1,e2)=>(samePt(e1[0],e2[0])&&samePt(e1[1],e2[1]))||(samePt(e1[0],e2[1])&&samePt(e1[1],e2[0])); const edgesOf=t=>[[t[0],t[1]],[t[1],t[2]],[t[2],t[0]]]; for(let i=0;i<tris.length;i++){ for(let j=i+1;j<tris.length;j++){ const ea=edgesOf(tris[i]), eb=edgesOf(tris[j]); for(const A of ea){ for(const B of eb){ if(sameEdge(A,B)){ map.get(i).push({to:j,edge:A}); map.get(j).push({to:i,edge:B}); } } } } } return map; }
export function pointInTri(p,tri){ const [a,b,c]=tri; const s1=triArea2(p,a,b), s2=triArea2(p,b,c), s3=triArea2(p,c,a); const eps=1e-6; const b1=s1<-eps,b2=s2<-eps,b3=s3<-eps; const z1=Math.abs(s1)<=eps,z2=Math.abs(s2)<=eps,z3=Math.abs(s3)<=eps; return (b1===b2&&b2===b3)||z1||z2||z3; }
export function findTriIdContaining(p, triangles){ for(let i=0;i<triangles.length;i++) if(pointInTri(p,triangles[i])) return i; return null; }
export function aStarTriangle(startId, goalId, triangles, adj, centroids){ if(startId==null||goalId==null) return null; const C=centroids||triangles.map(t=>centroidTriangle(t)); const open=new Set([startId]); const came=new Map(); const g=new Map([[startId,0]]); const f=new Map([[startId,V.dist(C[startId],C[goalId])]]); const pick=()=>{ let best=null,bv=Infinity; for(const n of open){ const v=f.get(n)??Infinity; if(v<bv){ bv=v; best=n; } } return best; }; while(open.size){ const cur=pick(); if(cur===goalId){ const ids=[cur]; let c=cur; while(came.has(c)){ c=came.get(c); ids.push(c);} return ids.reverse(); } open.delete(cur); for(const e of adj.get(cur)){ const alt=(g.get(cur)??Infinity)+V.dist(C[cur],C[e.to]); if(alt<(g.get(e.to)??Infinity)){ came.set(e.to,cur); g.set(e.to,alt); f.set(e.to,alt+V.dist(C[e.to],C[goalId])); open.add(e.to); } } } return null; }
const samePt=(p,q)=>p===q||(Math.abs(p.x-q.x)<1e-9&&Math.abs(p.y-q.y)<1e-9); function thirdVertex(tri,edge){ return tri.find(p=>p!==edge[0]&&p!==edge[1]); } function edgesOfTri(t){ return [[t[0],t[1]],[t[1],t[2]],[t[2],t[0]]]; } function orientedPortal(currTri,sharedEdge){ const a=sharedEdge[0], b=sharedEdge[1], q=thirdVertex(currTri,sharedEdge); return triArea2(a,b,q)>0?{left:{x:a.x,y:a.y}, right:{x:b.x,y:b.y}}:{left:{x:b.x,y:b.y}, right:{x:a.x,y:a.y}}; }
export function portalsFromTriPath(triPath, triangles, start, end){ const P=[]; for(let i=0;i<triPath.length-1;i++){ const curr=triangles[triPath[i]], next=triangles[triPath[i+1]]; const ea=edgesOfTri(curr), eb=edgesOfTri(next); let shared=null; outer: for(const A of ea){ for(const B of eb){ if((A[0]===B[0]&&A[1]===B[1])||(A[0]===B[1]&&A[1]===B[0])||(samePt(A[0],B[0])&&samePt(A[1],B[1]))||(samePt(A[0],B[1])&&samePt(A[1],B[0]))){ shared=A; break outer; } } } if(shared) P.push(orientedPortal(curr,shared)); } P.push({left:{x:end.x,y:end.y}, right:{x:end.x,y:end.y}}); return P; }
export function funnel(start, portals){ const EPS=1e-6; const out=[{x:start.x,y:start.y}]; let apex={x:start.x,y:start.y}; let left={x:portals[0].left.x,y:portals[0].left.y}; let right={x:portals[0].right.x,y:portals[0].right.y}; let ai=0,li=0,ri=0; function area(a,b,c){ return triArea2(a,b,c);} function veq(a,b){ return Math.abs(a.x-b.x)<=EPS&&Math.abs(a.y-b.y)<=EPS; } for(let i=1;i<portals.length;i++){ const pL=portals[i].left,pR=portals[i].right; if(area(apex,right,pR)<=EPS){ if(veq(apex,right)||area(apex,left,pR)>EPS){ right={x:pR.x,y:pR.y}; ri=i; } else { out.push({x:left.x,y:left.y}); apex={x:left.x,y:left.y}; ai=li; left={x:apex.x,y:apex.y}; right={x:apex.x,y:apex.y}; li=ai; ri=ai; i=ai; continue; } } if(area(apex,left,pL)>=-EPS){ if(veq(apex,left)||area(apex,right,pL)<-EPS){ left={x:pL.x,y:pL.y}; li=i; } else { out.push({x:right.x,y:right.y}); apex={x:right.x,y:right.y}; ai=ri; left={x:apex.x,y:apex.y}; right={x:apex.x,y:apex.y}; li=ai; ri=ai; i=ai; continue; } } } const last=portals[portals.length-1].left; if(!out.length||!samePt(out[out.length-1], last)) out.push({x:last.x,y:last.y}); return out; }
export function computeCentroids(triangles){ return triangles.map(t=>centroidTriangle(t)); }
